<!DOCTYPE html><html lang='en'><head><meta charset='UTF-8'><meta name='viewport' content='width=device-width, initial-scale=1.0'><meta http-equiv='X-UA-Compatible' content='ie=edge'><title>Document</title></head><link rel='stylesheet' href='../css/style.css'><link rel='stylesheet' href='../css/md.css'><body><div class='toplength'><div class='top'><a href='../index.html' class='topleft'>陈耀辉</a><a href='about.html' class='topright'>About</a></div></div><div class='contentbox'><div class='content'><div class='contentInner'><h1 id="canvas-">canvas动画技巧以及实用功能</h1>
<h3 id="requestanimationframe-">requestAnimationFrame定时器</h3>
<ul>
<li>大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms</li>
<li>而setTimeout和setInterval的问题是，它们都不精确。它们的内在运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行</li>
<li>requestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果  </li>
<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量</li>
<li>requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销</li>
<li>requestAnimationFrame的用法与settimeout很相似，只是不需要设置时间间隔而已。requestAnimationFrame使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。它返回一个整数，表示定时器的编号，这个值可以传递给cancelAnimationFrame用于取消这个函数的执行</li>
</ul>
<p>requestID = requestAnimationFrame(callback);<br>var timer = requestAnimationFrame(function(){<br>    console.log(0);<br>});<br>console.log(timer);//1<br>cancelAnimationFrame(timer); //取消定时器<br>cancelAnimationFrame(1);  //直接实用返回值取消定时器</p>
</div></div><div class=footer>@2016-2017</div></html>